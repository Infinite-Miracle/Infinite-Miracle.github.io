---
# C语言期末考试  
鬼知道数的因子是因数啊啊啊啊啊  



----
# WA常见错误
1. 算法使用错误   
2. 要取栈的前两个元素的时候经常写反，把栈里的第二个元素写成了k2（应该是栈顶元素）。先进后出导致思维习惯问题。

3. 函数漏写返回值。

4. 数组越界

5. 栈、队列等忘记push初始值，导致根本就没进行算法循环

6. 二分查找经常会写错

7. 精度错误

8. 输入顺序看反了

9. 条件语句中运算符优先级问题（不打括号的话&&优先于||，还有左右移和普通运算符的优先级问题）

10. 边界条件

11. 初始值问题

12. 局部变量问题（记忆犹新，让我de了一星期bug（真怀念当时闲的没事的时光啊）），递归函数中使用全局变量造成回溯的时候出问题。尽量使用局部变量！（x3）

13. 多维前缀和问题：以二维为例，区间（x1,y1,x2,y2）的和是（sum[x2,y2]+sum[x1-1,y1-1]-sum[x2,y1-1]-sum[x1-1,y2]），而不是sum[x2,y2]-sum[x1-1,y1-1]。这个已经犯了n次了。

14. 树状数组下标从1开始，而不是从0。

15. 忘记写cin>>t或者有N-1行输入数据但是输入了N组数据。

16. 题目看错了。

17. 数组没有初始化或者多组案例没有memset。
# OJ错误分类
Waiting：你的程序刚刚提交，正在等待OJ评测你的程序。
 
Compiling：OJ正在编译你的程序。
 
Accepted：OK!你的程序是正确的 ^_^。
 
Wrong Answer：你的程序运行的结果和正确结果不同。状态页面CASE那一览显示的是你的程序在第几个样例上出错的。
 
Time Limit Exceeded：你的程序运行时间太长了，超过了对应题目的时间限制。
 
Memory Limit Exceeded：你的程序运行所用的内存太多了，超过了对应题目的限制。
 
Output Limit Exceeded：你的程序输出了太多的内容了，超过了OJ的限制，轻检查你的程序中是否有可能存在无限循环输出。
 
Floating Point Error：Divide by 0，除0错误。
 
Segmentation Fault：有2中情况可能导致次错误：
 
buffer overflow -- 缓冲区溢出，也就是你访问 了非法内存，比如你神情了一个大小为2的数组a，却访问了a[10000]，或者在C/C++中访问了空指针等等。
 
stack overflow -- 堆栈溢出，有可能你在c/c++程序的函数中神情了过大的空间，或者递归层次太多，导致堆栈溢出了，轻记住堆栈的大小为8192KB.
 
Runtime Error：你的程序在运行的时候出错了，异常终止了，导致这种状态的情况有肯多，一般都是一些非法操作，比如文件操作，Java中的网络操作等等。 Java中Runtime Error的更详细的叙述见下。另外C/C++中越界访问函数中定义的数组也会导致Runtime Error。
 
Restricted Function：你的程序调用了不该调用的函数，比如fork(),execv(),socket等等危险的函数，清牢记一点：在你的程序中只作与解决问题有关的事情，尽情其他的操作都会被OJ拦截下来。
 
Compilation Error：编译错误，如果你的程序在本机能够正常编译，请在下面的编译出错怎么办查看更详细的解决办法。
 
Presentation Error：你的程序运行的结果是正确的，但是格式和正确结果有点不一样。比如中间多了回车或者空格，请仔细检查程序的输出部分，离AC就差一点点啦！
 
Presentation Error的一般原因?
 
PE就是没通过。 没通过就没成绩。 PE和wa, lte一样。?
 
一般原因：?
 
1.格式问题要注意 每行最后要有回车，并且行末不能有多余的空格。?
 
格式错误，请仔细检查case末的空行、case间的空行、每一行后的空格，等这些地方，看与题目描述是否一致。?
 
2.答案正确，但格式不对。   ?
 
可能是多输出了space/tab/return?
 
有人也说只有三种情况:?
 
1空行问题?
 
2大小写问题?
 
3空格问题?
 
所以又pe说明你没有根本错误，就是一些细节有错误。
 
下面是常见的OJ评判结果以及它们表示的意思：
 
Queuing : 提交太多了，OJ无法在第一时间给所有提交以评判结果，后面提交的程序将暂时处于排队状态等待OJ的评判。不过这个过程一般不会很长。
 
Compiling : 您提交的代码正在被编译。
 
Running : 您的程序正在OJ上运行。
 
Judging : OJ正在检查您程序的输出是否正确。
 
Accepted (AC) : 您的程序是正确的，恭喜！
 
Presentation Error (PE) : 虽然您的程序貌似输出了正确的结果，但是这个结果的格式有点问题。请检查程序的输出是否多了或者少了空格（' '）、制表符（'\t'）或者换行符（'\n'）。
 
Wrong Answer (WA) : 输出结果错，这个一般认为是算法有问题。
 
Runtime Error (RE) : 运行时错误，这个一般是程序在运行期间执行了非法的操作造成的。以下列出常见的错误类型：
 
ACCESS_VIOLATION 您的程序想从一些非法的地址空间读取或向其中写入内容。一般例如指针、数组下标越界都会造成这个错误的。      
ARRAY_BOUNDS_EXCEEDED 您的程序试图访问一个超出硬件支持范围的数组单元。    
FLOAT_DENORMAL_OPERAND 进行了一个非正常的浮点操作。一般是由于一个非正常的浮点数参与了浮点操作所引起的，比如这个数的浮点格式不正确。   
FLOAT_DIVIDE_BY_ZERO 浮点数除法出现除数为零的异常。  
FLOAT_OVERFLOW 浮点溢出。要表示的数太大，超出了浮点数的表示范围。   
FLOAT_UNDERFLOW 浮点下溢。要表示的数太小，超出了浮点数的表示范围。   
INTEGER_DIVIDE_BY_ZERO 在进行整数除法的时候出现了除数为零的异常。   
INTEGER_OVERFLOW 整数溢出。要表示的数值太大，超出了整数变量的范围。      
STACK_OVERFLOW 栈溢出。一般是由于无限递归或者在函数里使用了太大的数组变量的原因。顾名思义，stack overflow 就是是栈溢出了。在进行数值运算时，我们常常要和运算结果的溢出打交道。数值运算结果可能上溢（overflow），也可能是下溢 （underflow）。不过栈的溢出显然只可能是上溢，即栈空间被用完了。
要正确处理栈溢出采用以下办法：  
（1）修正我们的程序，不要造成无穷递归或太深的递归。我们可以把某些递归代码非递归化，例如那个经典的 qsort ，最好就用非递归的算法来实现，就比较皮实一点。
（2）修正我们的程序，不要定义过大的局部变量，特别是在定义大结构、大数组时要格外小心。有时我们可能会用 _alloca() 这样的特殊函数直接在栈上分配空间，更要多加注意。可以定义成static
（3）利用编译器的特性，将进程允许的栈大小设置得大一些。例如可以采用 MSC 中的 /STACK 参数开关。
（4） 对于那些还可能导致栈溢出的代码，采用 Microsoft 的结构化异常处理或标准的 C++ 异常处理机制，结合 _resetstkoflw() 进行处理。当然了，要是不嫌麻烦，我们也可以自己探测所用栈的大小，动态地检测是否可能导致栈溢出，以避免可能的异常。
...... 其他错误，包括C++标准库/STL运行时库错误等，这里不再举例。
 
Time Limit Exceeded (TLE) : 您的程序运行的时间已经超出了这个题目的时间限制。
 
Memory Limit Exceeded (MLE) : 您的程序运行的内存已经超出了这个题目的内存限制。
 
Output Limit Exceeded (OLE) : 您的程序输出内容太多，超过了这个题目的输出限制。
 
Compilation Error (CE) : 您的程序语法有问题，编译器无法编译。具体的出错信息可以点击链接察看。
 
System Error (SE) : OJ内部出现错误。由于我们的OJ可能存在一些小问题，所以出现这个信息请原谅，同时请及时与管理员联系。
 
Out Of Contest Time : 超出比赛时间，这个信息只有在比赛的时候才会出现

不同 OJ 有不同的错误代码，有些 OJ 没有 PE,SE 啥的，甚至有没有 TLE，RE 的 OJ，具体的要根据 OJ 分析，最好比赛前要测试下错误代码的种类，方便赛时找 bug。
# 错误解决
Wrong Answer ：答案错误
输出的答案错误，具体问题各不相同，大概有这几种情况

1. 代码哪里写出 bug 了，代码功能与自己想实现的功能相异。

2. 解题逻辑和思路错误。

3. 特殊情况没有处理，比如 0，1，2 和最大值这种边界值没有考虑。

4. 空间开的不够大，造成越界，但越界并没有进行修改，或者修改的数据不是关键数据，导致不触发 RE，但因为访问或者修改的错误的数据，导致输出结果错误。

Runtime Error ：运行时错误
你的程序在运行的时候出错了，异常终止了。

1. 越界，想从一些非法的地址空间读取或向其中写入内容。

2. 除 0 或模 0 错误

3. 过多的申请栈内存导致栈溢出，如无限或过多的递归，在 main 函数中申请空间（此项由于不同 OJ 设置可能会有出入，有些 OJ 堆栈内存共享）。

4. 使用 STL 的非法操作，比如从空 stack 中取 top。

Presentation Error :输出格式错误
答案正确但没按题目要求输出，注意读题，或者行末空格，和最后一行输出的换行。

Time Limit Exceeded :时间超限
程序运行时间太长了，超过了对应题目的时间限制。

1. 代码无限循环。

2. 算法复杂度过大。

Output Limit Exceeded:输出超限
程序输出了太多的内容了，超过了 OJ 的限制。

Memory Limit Exceeded：内存超限
程序运行所用的内存太多了，超过了对应题目的限制。

1. 内存空间申请过大。

2. 在有些 oj（cf，洛谷）中，堆栈共享内存空间，这时当你出现过多的递归这种大量的栈内存使用的时候，不会栈溢出导致 RE，而是内存超限导致 MLE。

Compile Error :编译错误
程序编译错误

1. 编译器选取错误，使用高版本的特性，却使用低版本编译器。

2. 头文件问题，使用 window 系统的头文件，但 OJ 却是 linux 系统，少添加了头文件。

Floating Point Error：除零错误
有些 OJ 除零错误有专门的错误代码

Segmentation Fault：段错误
类似 RE。

1. 缓冲区溢出，也就是你访问 了非法内存，，或者在 C/C++ 中访问了空指针等等。

2. 堆栈溢出。

Restricted Function：受限函数
调用了不该调用的函数，如 fork (),execv (),socket () 等


# 下面是你所请求的函数的简单实现：

（1）isLeapYear(int year)：判断是否为闰年
```c
int isLeapYear(int year) {
    if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0) {
        return 1; // 是闰年
    }
    return 0; // 不是闰年
}
```

（2）dayofMonth(int year, int month)：返回指定年份某个月份的天数
```c
int dayofMonth(int year, int month) {
    int days[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    if (isLeapYear(year) && month == 2) {
        return 29; // 闰年2月有29天
    }
    return days[month - 1];
}
```

（3）dayofYear(int year, int month, int day)：返回指定日期是该年的第几天
```c
int dayofYear(int year, int month, int day) {
    int days = day;
    for (int i = 1; i < month; i++) {
        days += dayofMonth(year, i);
    }
    return days;
}
```

（4）isPrime(int num)：判断一个数是否为素数
```c
int isPrime(int num) {
    if (num <= 1) {
        return 0; // 不是素数
    }
    for (int i = 2; i * i <= num; i++) {
        if (num % i == 0) {
            return 0; // 不是素数
        }
    }
    return 1; // 是素数
}
```

（5）isPalindrome(int num)：判断一个整数是否为回文数
```c
int isPalindrome(int num) {
    int reversed = 0;
    int temp = num;
    while (temp > 0) {
        reversed = reversed * 10 + temp % 10;
        temp /= 10;
    }
    return reversed == num;
}
```

（6）isPalindrome(char *str)：判断一个字符串是否为回文字符串
```c
int isPalindrome(char *str) {
    int len = strlen(str);
    for (int i = 0, j = len - 1; i < j; i++, j--) {
        if (str[i] != str[j]) {
            return 0; // 不是回文字符串
        }
    }
    return 1; // 是回文字符串
}
```

（7）gcd(int a, int b)：求两个数的最大公约数
```c
int gcd(int a, int b) {
    if (b == 0) {
        return a;
    }
    return gcd(b, a % b);
}
```

（8）bubbleSort(int data[], int len)：冒泡排序（升序或降序）
```c
void bubbleSort(int data[], int len) {
    for (int i = 0; i < len - 1; i++) {
        for (int j = 0; j < len - i - 1; j++) {
            if (data[j] > data[j + 1]) { // 升序排序，如需降序则改为data[j] < data[j + 1]
                int temp = data[j];
                data[j] = data[j + 1];
                data[j + 1] = temp;
            }
        }
    }
}
```

（9）quickSort(int data[], int len)：快速排序
```c
void quickSort(int data[], int left, int right) {
    if (left >= right) {
        return;
    }
    int pivot = data[left];
    int i = left, j = right;
    while (i < j) {
        while (i < j && data[j] >= pivot) {
            j--;
        }
        data[i] = data[j];
        while (i < j && data[i] <= pivot) {
            i++;
        }
        data[j] = data[i];
    }
    data[i] = pivot;
    quickSort(data, left, i - 1);
    quickSort(data, i + 1, right);
}

// 调用函数：
// quickSort(data, 0, len - 1);
```

（10）bubbleSort(struct XX data[], int len)：根据结构体成员或多个结构体成员的组合条件进行排序
```c
struct XX {
    int num;
    char name[20];
};

void bubbleSort(struct XX data[], int len) {
    for (int i = 0; i < len - 1; i++) {
        for (int j = 0; j < len - i - 1; j++) {
            // 根据结构体成员排序，如需根据多个成员的组合条件排序，可在if语句中添加逻辑条件
            if (data[j].num > data[j + 1].num) {
                struct XX temp = data[j];
                data[j] = data[j + 1];
                data[j + 1] = temp;
            }
        }
    }
}
```

（11）Top10000PrimeNumbers()：输出前10000个素数
```c
void Top10000PrimeNumbers() {
    int count = 0;
    int num = 2;
    while (count < 10000) {
        if (isPrime(num)) {
            printf("%d ", num);
            count++;
        }
        num++;
    }
}
```

（12）递归函数的使用示例：汉诺塔、n的阶乘、斐波那契数列
```c
// 汉诺塔
void hanoiTower(int n, char from, char to, char aux) {
    if (n == 1) {
        printf("Move disk 1 from %c to %c\n", from, to);
        return;
    }
    hanoiTower(n - 1, from, aux, to);
    printf("Move disk %d from %c to %c\n", n, from, to);
    hanoiTower(n - 1, aux, to, from);
}

// n的阶乘
int factorial(int n) {
    if (n == 0 || n == 1) {
        return 1;
    }
    return n * factorial(n - 1);
}

// 斐波那契数列
int fibonacci(int n) {
    if (n == 0 || n == 1) {
        return n;
    }
    return fibonacci(n - 1) + fibonacci(n - 2);
}
```
```c
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

int a[1000],b[1000],c[1000];
 
//返回两者较大值 
int max(int a,int b){
	if(a>b)return a;
	else return b;
}

//将数组设置为0 
int setZero(int*num,int len){
	for(int i=0;i<len;i++)
		num[i]=0;
}

//比较两个数组形式数字大小 
int compare(int*num1,int*num2){
	int i,j;
	for(i=999;num1[i]==0;i--);
	for(j=999;num2[j]==0;j--);
	if(i<j)return -1;
	else if(i>j)return 1;
	else{
		for(;i>=0;i--){
			if(num1[i]>num2[i])
				return 1;
			else if(num1[i]<num2[i])
				return -1;
		}
		return 0;
	}
}

//将一个数组赋给另一个数组 
int copy(int*num1,int*num2){
	int i,j;
	for(i=0;i<1000;i++)
		num1[i]=0;
	for(i=999;num2[i]==0;i--);
	for(j=0;j<=i;j++)
		num1[j]=num2[j];
	return i+1;
}

//大数加法 
void add(char*str1,char*str2){
	setZero(a,1000);
	setZero(b,1000);
	setZero(c,1000);
	printf("%s + %s = ",str1,str2);
		
	int i,carry=0;
	int len1=strlen(str1),len2=strlen(str2),len=max(len1,len2);
	for(i=0;i<len1;i++)
		a[i]=str1[len1-1-i]-'0';
	for(i=0;i<len2;i++)
		b[i]=str2[len2-1-i]-'0';
	for(i=0;i<len;i++){
		c[i]=(a[i]+b[i]+carry)%10;
		carry=(a[i]+b[i]+carry)/10;
	}
	

	if(carry!=0)
		c[len++]=1;
	for(i=len-1;i>=0;i--)
		printf("%d",c[i]);
	printf("\n");
}

//大数减法 
void sub(char*str1,char*str2){
	setZero(a,1000);
	setZero(b,1000);
	setZero(c,1000);
	printf("%s - %s = ",str1,str2);
	
	int i,borrow=0;
	int len1=strlen(str1),len2=strlen(str2),len=max(len1,len2);
	for(i=0;i<len1;i++)
		a[i]=str1[len1-1-i]-'0';
	for(i=0;i<len2;i++)
		b[i]=str2[len2-1-i]-'0';	
	
	//初步根据位数判断两数大小	
	if(len2>len1){ 
		printf("-");
		for(i=0;i<len;i++){
			c[i]=b[i]-a[i]-borrow;
			if(c[i]<0){
				borrow=1;
				c[i]+=10;
			}
			else
				borrow=0;
		}
	}
	else{
		for(i=0;i<len;i++){
			c[i]=a[i]-b[i]-borrow;
			if(c[i]<0&&i+1<len){
				borrow=1;
				c[i]+=10;
			}
			else
				borrow=0;
		}
	}
	//如果发现被减数小于减数，则重新计算，用减数减去被减数，输出负号 
	if(c[len-1]<0){
		printf("-");
		for(i=0;i<len;i++){
			c[i]=b[i]-a[i]-borrow;
			if(c[i]<0&&i+1<len){
				borrow=1;
				c[i]+=10;
			}
			else
				borrow=0;
		}
	}
	
	
	while(c[len-1]==0&&len>1)
		len--;
	for(i=len-1;i>=0;i--)
		printf("%d",c[i]);
	printf("\n");
}

//大数乘法 
void mul(char*str1,char*str2) {
	setZero(a,1000);
	setZero(b,1000);
	setZero(c,1000);
	printf("%s * %s = ",str1,str2);
	
	int i,j,k,carry=0,tmp; 
	int len1=strlen(str1),len2=strlen(str2);
	for(i=0;i<len1;i++)
		a[i]=str1[len1-1-i]-'0';
	for(i=0;i<len2;i++)
		b[i]=str2[len2-1-i]-'0';
	
	for(i=0;i<len1;i++){
		for(k=i,j=0;j<len2;j++,k++){
			c[k]+=a[i]*b[j];
		}
	}
	for(i=0;i<=k;i++) {
		c[i]+=carry;
		tmp=c[i];
		c[i]=tmp%10;
		carry=tmp/10;
	}
	
	for(i=k;c[i]==0;i--);
	for(;i>=0;i--)
		printf("%d",c[i]);
	printf("\n");
}


//大数除法 
void div(char*str1,char*str2){
	setZero(a,1000);
	setZero(b,1000);
	setZero(c,1000);
	printf("%s / %s = ",str1,str2);
	
	int i,j,tmp,tmp2=0,borrow=0,temp[1000]={0},temp2[1000]={0};
	int len1=strlen(str1),len2=strlen(str2);
	for(i=0;i<len1;i++)
		a[i]=str1[len1-1-i]-'0';
	for(i=0;i<len2;i++)
		b[i]=str2[len2-1-i]-'0';
	
	if(compare(a,b)<0){
		printf("0\n");
		return;
	}
	
	while(compare(a,b)>=0){			
		tmp=len1-len2;
		if(tmp==tmp2&&tmp>0)
			tmp--;
		tmp2=tmp;
		
		setZero(temp2,1000);
		for(i=len1-1;i>=tmp;i--)
			temp2[i]=b[i-tmp];
		copy(temp,a);
		
		if(compare(temp,temp2)<0)
				continue;
		for(j=1;;j++){
			borrow=0;
			for(i=tmp;i<len1;i++){
				temp[i]=a[i]-temp2[i]-borrow;
				if(temp[i]<0){
					borrow=1;
					temp[i]+=10;
				}
				else
					borrow=0;
			}
			
			len1=copy(a,temp);			
			c[tmp]=j;
			if(compare(temp,temp2)<0)
				break;
		}
	}
	
	for(i=999;c[i]==0;i--);
	for(;i>=0;i--)
		printf("%d",c[i]);
	printf("\n");
}

int main() {
	add("265151916516519419516","15616651622161651616");
	sub("163165165161984116165","15454874487989819449");
	mul("798794149194949451949","98491516194941631316");
	div("16516498416516516191981916516165","12345678");
}
/*
void mul(char*str1,char*str2,char*out) {
	setZero(a,1000);
	setZero(b,1000);
	setZero(c,1000);
	
	int i,j,k,carry=0,tmp; 
	int len1=strlen(str1),len2=strlen(str2);
	for(i=0;i<len1;i++)
		a[i]=str1[len1-1-i]-'0';
	for(i=0;i<len2;i++)
		b[i]=str2[len2-1-i]-'0';
	
	for(i=0;i<len1;i++){
		for(k=i,j=0;j<len2;j++,k++){
			c[k]+=a[i]*b[j];
		}
	}
	for(i=0;i<=k;i++) {
		c[i]+=carry;
		tmp=c[i];
		c[i]=tmp%10;
		carry=tmp/10;
	}
	
	for(i=k;c[i]==0;i--);
    int d=i;
	for(;i>=0;i--){
        out[d-i]=c[i]+'0';
    }
}
*/
```
```c

#include<stdio.h>
#include <math.h>
#include <limits.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

//yi shang mei yong 
void sort_jichu(int a,int b){
    int p;
    p=a;
    a=b;
    b=p;
}



double zifuhuanshuzi(char ch[]){
    int dd=strlen(ch);//chang du,yong yv ji suan wei shu
    double pp=0;//pp wei jiang lai de ji suan shu zi jie guo
    int i=0;//kong zhi xun huan ci shu
    while (1) {
        if (i==dd) {
            break;
        }
        /*
        ye ke yi
        if(ch[i]='\0'){
            break;
        }
        */
        if (ch[i]=='-') {
            i++;
            continue;
        }
        int mm=(int)ch[i]-48; //mm wei mei yi wei shang de shu zhi
        pp=pp+mm*pow(10, dd-i-1);//mei yi wei de wei zhi
        i++;
    }
    return pp;
}



int shuzihuiwen(int n){
    int reversed_n=0;
    while (n > 0) {
        int digit = n % 10;
        reversed_n = reversed_n * 10 + digit;
        n /= 10;
    }
    return reversed_n;
}



void dashuxiangjia(char n[],char m[],char j[]){
    //dou shi zheng de
    
    /*int a,b,c,d;
    a=strlen(n);
    b=strlen(m);
    c=a-b;
    if (c>0) {
        d=b;
    }
    else {
        d=a;
    }*/
    //xian yong zhe ge pan duan xia na ge chang
    int a=strlen(n);
    int b=strlen(m);
    int d=a;//zhe li mo ren n duan
    char pp[10086];
    int q,ii=0,jin=0;
    for (int i=d-1;i>-1;i--) {
        q=n[i]-'0'+m[b-1-ii]-'0'+jin;
        jin=q/10;
        q=q%10;
        pp[ii]=q+'0';
        ii++;
    }
    int hhh=0,dd;
    if(jin==1){
        for (int up=b-a;up>-1;up--) {
            dd=m[up-1]-'0'+1;
            if(dd!=10) {
                pp[ii]=m[up-1]+1;
                break;
            }
            pp[ii]='0';
            ii++;
        }
    ii++;
    }
    for (int kk=b-ii-1;kk>-1;kk--) {
        pp[ii]=m[kk];
        ii++;
    }

    for (int yy=0;yy<=ii;yy++) {
        j[yy]=pp[ii-1-yy];
    }
}



void huiwenshuzizifuchuan(char ch[]){
    while (scanf("%s",ch)!=EOF) {
        int m=strlen(ch);
        char op[10086]={'0'};
        int ii;
        if (ch[0]=='-') {
            ii=1;
            op[0]='-';
            for (int i=m-1;i>0;i--) {
            op[ii]=ch[i];
            ii++;
            } 
        }
        else {
            ii=0;
            for (int i=m-1;i>-1;i--) {
                op[ii]=ch[i];
                ii++;
            }
        }
    }
}


void panduansushu(int i){////
    int aa=0;
    for (int p=2;p*p<=i;p++) {
            if(i%p==0){
                aa--;
                break;
            }
        }
    if (aa==0) {
        printf("YES");
    }
    else {
        printf("NO");
    }
}
//su shu yong de hua yi wei shu zu jia biao ji jiu xing

//su shu
/*2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997,1009,1013,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,1297,1301,1303,1307,1319,1321,1327,1361,1367,1373,1381,1399,1409,1423,1427,1429,1433,1439,1447,1451,1453,1459,1471,1481,1483,1487,1489,1493,1499,1511,1523,1531,1543,1549,1553,1559,1567,1571,1579,1583,1597,1601,1607,1609,1613,1619,1621,1627,1637,1657,1663,1667,1669,1693,1697,1699,1709,1721,1723,1733,1741,1747,1753,1759,1777,1783,1787,1789,1801,1811,1823,1831,1847,1861,1867,1871,1873,1877,1879,1889,1901,1907,1913,1931,1933,1949,1951,1973,1979,1987,1993,1997,1999,1999,2003,2011,2017,2027,2029,2039,2053,2063,2069,2081,2083,2087,2089,2099,2111,2113,2129,2131,2137,2141,2143,2153,2161,2179,2203,2207,2213,2221,2237,2239,2243,2251,2267,2269,2273,2281,2287,2293,2297,2309,2311,2333,2339,2341,2347,2351,2357,2371,2377,2381,2383,2389,2393,2399,2411,2417,2423,2437,2441,2447,2459,2467,2473,2477,2503,2521,2531,2539,2543,2549,2551,2557,2579,2591,2593,2609,2617,2621,2633,2647,2657,2659,2663,2671,2677,2683,2687,2689,2693,2699,2707,2711,2713,2719,2729,2731,2741,2749,2753,2767,2777,2789,2791,2797,2801,2803,2819,2833,2837,2843,2851,2857,2861,2879,2887,2897,2903,2909,2917,2927,2939,2953,2957,2963,2969,2971,2999,3001,3011,3019,3023,3037,3041,3049,3061,3067,3079,3083,3089,3109,3119,3121,3137,3163,3167,3169,3181,3187,3191,3203,3209,3217,3221,3229,3251,3253,3257,3259,3271,3299,3301,3307,3313,3319,3323,3329,3331,3343,3347,3359,3361,3371,3373,3389,3391,3407,3413,3433,3449,3457,3461,3463,3467,3469,3491,3499,3511,3517,3527,3529,3533,3539,3541,3547,3557,3559,3571,3581,3583,3593,3607,3613,3617,3623,3631,3637,3643,3659,3671,3673,3677,3691,3697,3701,3709,3719,3727,3733,3739,3761,3767,3769,3779,3793,3797,3803,3821,3823,3833,3847,3851,3853,3863,3877,3881,3889,3907,3911,3917,3919,3923,3929,3931,3943,3947,3967,3989,4001,4003,4007,4013,4019,4021,4027,4049,4051,4057,4073,4079,4091,4093,4099,4111,4127,4129,4133,4139,4153,4157,4159,4177,4201,4211,4217,4219,4229,4231,4241,4243,4253,4259,4261,4271,4273,4283,4289,4297,4327,4337,4339,4349,4357,4363,4373,4391,4397,4409,4421,4423,4441,4447,4451,4457,4463,4481,4483,4493,4507,4513,4517,4519,4523,4547,4549,4561,4567,4583,4591,4597,4603,4621,4637,4639,4643,4649,4651,4657,4663,4673,4679,4691,4703,4721,4723,4729,4733,4751,4759,4783,4787,4789,4793,4799,4801,4813,4817,4831,4861,4871,4877,4889,4903,4909,4919,4931,4933,4937,4943,4951,4957,4967,4969,4973,4987,4993,4999,5003,5009,5011,5021,5023,5039,5051,5059,5077,5081,5087,5099,5101,5107,5113,5119,5147,5153,5167,5171,5179,5189,5197,5209,5227,5231,5233,5237,5261,5273,5279,5281,5297,5303,5309,5323,5333,5347,5351,5381,5387,5393,5399,5407,5413,5417,5419,5431,5437,5441,5443,5449,5471,5477,5479,5483,5501,5503,5507,5519,5521,5527,5531,5557,5563,5569,5573,5581,5591,5623,5639,5641,5647,5651,5653,5657,5659,5669,5683,5689,5693,5701,5711,5717,5737,5741,5743,5749,5779,5783,5791,5801,5807,5813,5821,5827,5839,5843,5849,5851,5857,5861,5867,5869,5879,5881,5897,5903,5923,5927,5939,5953,5981,5987,6007,6011,6029,6037,6043,6047,6053,6067,6073,6079,6089,6091,6101,6113,6121,6131,6133,6143,6151,6163,6173,6197,6199,6203,6211,6217,6221,6229,6247,6257,6263,6269,6271,6277,6287,6299,6301,6311,6317,6323,6329,6337,6343,6353,6359,6361,6367,6373,6379,6389,6397,6421,6427,6449,6451,6469,6473,6481,6491,6521,6529,6547,6551,6553,6563,6569,6571,6577,6581,6599,6607,6619,6637,6653,6659,6661,6673,6679,6689,6691,6701,6703,6709,6719,6733,6737,6761,6763,6779,6781,6791,6793,6803,6823,6827,6829,6833,6841,6857,6863,6869,6871,6883,6899,6907,6911,6917,6947,6949,6959,6961,6967,6971,6977,6983,6991,6997,7001,7013,7019,7027,7039,7043,7057,7069,7079,7103,7109,7121,7127,7129,7151,7159,7177,7187,7193,7207,7211,7213,7219,7229,7237,7243,7247,7253,7283,7297,7307,7309,7321,7331,7333,7349,7351,7369,7393,7411,7417,7433,7451,7457,7459,7477,7481,7487,7489,7499,7507,7517,7523,7529,7537,7541,7547,7549,7559,7561,7573,7577,7583,7589,7591,7603,7607,7621,7639,7643,7649,7669,7673,7681,7687,7691,7699,7703,7717,7723,7727,7741,7753,7757,7759,7789,7793,7817,7823,7829,7841,7853,7867,7873,7877,7879,7883,7901,7907,7919,7927,7933,7937,7949,7951,7963,7993,8009,8011,8017,8039,8053,8059,8069,8081,8087,8089,8093,8101,8111,8117,8123,8147,8161,8167,8171,8179,8191,8209,8219,8221,8231,8233,8237,8243,8263,8269,8273,8287,8291,8293,8297,8311,8317,8329,8353,8363,8369,8377,8387,8389,8419,8423,8429,8431,8443,8447,8461,8467,8501,8513,8521,8527,8537,8539,8543,8563,8573,8581,8597,8599,8609,8623,8627,8629,8641,8647,8663,8669,8677,8681,8689,8693,8699,8707,8713,8719,8731,8737,8741,8747,8753,8761,8779,8783,8803,8807,8819,8821,8831,8837,8839,8849,8861,8863,8867,8887,8893,8923,8929,8933,8941,8951,8963,8969,8971,8999,9001,9007,9011,9013,9029,9041,9043,9049,9059,9067,9091,9103,9109,9127,9133,9137,9151,9157,9161,9173,9181,9187,9199,9203,9209,9221,9227,9239,9241,9257,9277,9281,9283,9293,9311,9319,9323,9337,9341,9343,9349,9371,9377,9391,9397,9403,9413,9419,9421,9431,9433,9437,9439,9461,9463,9467,9473,9479,9491,9497,9511,9521,9533,9539,9547,9551,9587,9601,9613,9619,9623,9629,9631,9643,9649,9661,9677,9679,9689,9697,9719,9721,9733,9739,9743,9749,9767,9769,9781,9787,9791,9803,9811,9817,9829,9833,9839,9851,9857,9859,9871,9883,9887,9901,9907,9923,9929,9931,9941,9949,9967,9973,10007,10009,10037,10039,10061,10067,10069,10079,10091,10093,10099,10103,10111,10133,10139,10141,10151,10159,10163,10169,10177,10181,10193,10211,10223,10243,10247,10253,10259,10267,10271,10273,10289,10301,10303,10313,10321,10331,10333,10337,10343,10357,10369,10391,10399,10427,10429,10433,10453,10457,10459,10463,10477,10487,10499,10501,10513,10529,10531,10559,10567,10589,10597,10601,10607,10613,10627,10631,10639,10651,10657,10663,10667,10687,10691,10709,10711,10723,10729,10733,10739,10753,10771,10781,10789,10799,10831,10837,10847,10853,10859,10861,10867,10883,10889,10891,10903,10909,10937,10939,10949,10957,10973,10979,10987,10993,11003,11027,11047,11057,11059,11069,11071,11083,11087,11093,11113,11117,11119,11131,11149,11159,11161,11171,11173,11177,11197,11213,11239,11243,11251,11257,11261,11273,11279,11287,11299,11311,11317,11321,11329,11351,11353,11369,11383,11393,11399,11411,11423,11437,11443,11447,11467,11471,11483,11489,11491,11497,11503,11519,11527,11549,11551,11579,11587,11593,11597,11617,11621,11633,11657,11677,11681,11689,11699,11701,11717,11719,11731,11743,11777,11779,11783,11789,11801,11807,11813,11821,11827,11831,11833,11839,11863,11867,11887,11897,11903,11909,11923,11927,11933,11939,11941,11953,11959,11969,11971,11981,11987,12007,12011,12037,12041,12043,12049,12071,12073,12097,12101,12107,12109,12113,12119,12143,12149,12157,12161,12163,12197,12203,12211,12227,12239,12241,12251,12253,12263,12269,12277,12281,12289,12301,12323,12329,12343,12347,12373,12377,12379,12391,12401,12409,12413,12421,12433,12437,12451,12457,12473,12479,12487,12491,12497,12503,12511,12517,12527,12539,12541,12547,12553,12569,12577,12583,12589,12601,12611,12613,12619,12637,12641,12647,12653,12659,12671,12689,12697,12703,12713,12721,12739,12743,12757,12763,12781,12791,12799,12809,12821,12823,12829,12841,12853,12889,12893,12899,12907,12911,12917,12919,12923,12941,12953,12959,12967,12973,12979,12983,13001,13003,13007,13009,13033,13037,13043,13049,13063,13093,13099,13103,13109,13121,13127,13147,13151,13159,13163,13171,13177,13183,13187,13217,13219,13229,13241,13249,13259,13267,13291,13297,13309,13313,13327,13331,13337,13339,13367,13381,13397,13399,13411,13417,13421,13441,13451,13457,13463,13469,13477,13487,13499,13513,13523,13537,13553,13567,13577,13591,13597,13613,13619,13627,13633,13649,13669,13679,13681,13687,13691,13693,13697,13709,13711,13721,13723,13729,13751,13757,13759,13763,13781,13789,13799,13807,13829,13831,13841,13859,13873,13877,13879,13883,13901,13903,13907,13913,13921,13931,13933,13963,13967,13997,13999,14009,14011,14029,14033,14051,14057,14071,14081,14083,14087,14107,14143,14149,14153,14159,14173,14177,14197,14207,14221,14243,14249,14251,14281,14293,14303,14321,14323,14327,14341,14347,14369,14387,14389,14401,14407,14411,14419,14423,14431,14437,14447,14449,14461,14479,14489,14503,14519,14533,14537,14543,14549,14551,14557,14561,14563,14591,14593,14621,14627,14629,14633,14639,14653,14657,14669,14683,14699,14713,14717,14723,14731,14737,14741,14747,14753,14759,14767,14771,14779,14783,14797,14813,14821,14827,14831,14843,14851,14867,14869,14879,14887,14891,14897,14923,14929,14939,14947,14951,14957,14969,14983,15013,15017,15031,15053,15061,15073,15077,15083,15091,15101,15107,15121,15131,15137,15139,15149,15161,15173,15187,15193,15199,15217,15227,15233,15241,15259,15263,15269,15271,15277,15287,15289,15299,15307,15313,15319,15329,15331,15349,15359,15361,15373,15377,15383,15391,15401,15413,15427,15439,15443,15451,15461,15467,15473,15493,15497,15511,15527,15541,15551,15559,15569,15581,15583,15601,15607,15619,15629,15641,15643,15647,15649,15661,15667,15671,15679,15683,15727,15731,15733,15737,15739,15749,15761,15767,15773,15787,15791,15797,15803,15809,15817,15823,15859,15877,15881,15887,15889,15901,15907,15913,15919,15923,15937,15959,15971,15973,15991,16001,16007,16033,16057,16061,16063,16067,16069,16073,16087,16091,16097,16103,16111,16127,16139,16141,16183,16187,16189,16193,16217,16223,16229,16231,16249,16253,16267,16273,16301,16319,16333,16339,16349,16361,16363,16369,16381,16411,16417,16421,16427,16433,16447,16451,16453,16477,16481,16487,16493,16519,16529,16547,16553,16561,16567,16573,16603,16607,16619,16631,16633,16649,16651,16657,16661,16673,16691,16693,16699,16703,16729,16741,16747,16759,16763,16787,16811,16823,16829,16831,16843,16871,16879,16883,16889,16901,16903,16921,16927,16931,16937,16943,16963,16979,16981,16987,16993,17011,17021,17027,17029,17033,17041,17047,17053,17077,17093,17099,17107,17117,17123*/

void yanghuisanjiaodeshixian(){
    int i;
    scanf("%d",&i);
    int a[40][40];
    for (int p=0; p<i;p++) {
        a[p][0]=1;
        a[p][p]=1;
    }
    for (int hi=2; hi<i;hi++) {
        for (int u=1;u<hi;u++ ) {
            a[hi][u]=a[hi-1][u]+a[hi-1][u-1];
        }
    }
}
void yanghuisanjiaodeshuchu(int i,int a[][10000]){
    for (int bb=0; bb<i;bb++) {
        for (int hh=0;hh<bb+1;hh++) {
            printf("%d ",a[bb][hh]);
        }
        printf("\n");
    }
}

```
```c
#include <stdio.h>
#include <string.h>
int main(){
    long long n;
    while (scanf("%lld",&n)!=EOF) {
        char a[101];
        sprintf(a, "%lld",n);
        int len=strlen(a);
        long long hi;
        if (a[0]!='-') {
            for (int i=0; i<len/2;i++) {
                char m=a[i];
                a[i]=a[len-1-i];
                a[len-1-i]=m;
            }
            sscanf(a, "%lld",&hi);
        }
        else {
            char lp[100];
            for (int i=0; i<len-1;i++) {
                lp[i]=a[len-1-i];
            }
            sscanf(lp,"%lld",&hi);
            hi=0-hi;
        }
        printf("%lld\n",hi);
    }
    return 0;
}
```
```c
#include <stdio.h>
int main(){
    int t;
    scanf("%d",&t);
    for (int i=0;i<t;i++) {
        int a,b;
        int m=0;
        scanf("%d %d",&a,&b);
        for (int i=a;i<=b;i++) {
            if (i%6==0) {
                int d=b-i;
                d=d/6;
                m+=2;
                m+=2*d;
                break;
            }
            if (i%2==0||i%3==0) {
                continue;
            }
            m++;
        }
        if (b%6==0) {
            m--;
        }
        if (b%6==5) {
            m++;
        }
        printf("%d\n",m-1);
    }
    return 0;
}
```
```c
#include <stdio.h>
int panduansushu(int i){
    int aa=0;
    for (int p=2;p*p<=i;p++) {
            if(i%p==0){
                aa--;
                break;
            }
        }
    if (aa==0) {
        return 1;
    }
    else {
        return 0;
    }
}
int main(){
    int n;
    while (scanf("%d",&n)!=EOF) {
        int m;
        int p=n-2;
        if (panduansushu(p)&&p!=0) {
            m=1;
        }
        else {
            m=0;
        }
        for (int i=3;i<(n+1)/2;i+=2) {
            int d=n-i;
            int ii=panduansushu(i);
            int dd=panduansushu(d);
            if (ii&&dd) {
                m++;
            }
        }
        printf("%d\n",m);
    }
    return 0;
}
```
```c
#include <stdio.h>
#include <string.h>
int a[1000],b[1000],c[1000];
int setZero(int*num,int len){
	for(int i=0;i<len;i++)
		num[i]=0;
    return 0;
}
int max(int a,int b){
	if(a>b)return a;
	else return b;
}
void add(char*str1,char*str2,char*ad){
	setZero(a,1000);
	setZero(b,1000);
	setZero(c,1000);
	printf("%s + %s = ",str1,str2);
		
	int i,carry=0;
	int len1=strlen(str1),len2=strlen(str2),len=max(len1,len2);
	for(i=0;i<len1;i++)
		a[i]=str1[len1-1-i]-'0';
	for(i=0;i<len2;i++)
		b[i]=str2[len2-1-i]-'0';
	for(i=0;i<len;i++){
		c[i]=(a[i]+b[i]+carry)%10;
		carry=(a[i]+b[i]+carry)/10;
	}
	
	if(carry!=0)
		c[len++]=1;
    
	for(i=len-1;i>=0;i--){
		printf("%d",c[i]);
        ad[len-1-i]=c[i]+'0';
    }
	printf("\n");
}
//大数乘法 
void mul(char*str1,char*str2,char*out) {
	setZero(a,1000);
	setZero(b,1000);
	setZero(c,1000);
	printf("%s * %s = ",str1,str2);
	
	int i,j,k,carry=0,tmp; 
	int len1=strlen(str1),len2=strlen(str2);
	for(i=0;i<len1;i++)
		a[i]=str1[len1-1-i]-'0';
	for(i=0;i<len2;i++)
		b[i]=str2[len2-1-i]-'0';
	
	for(i=0;i<len1;i++){
		for(k=i,j=0;j<len2;j++,k++){
			c[k]+=a[i]*b[j];
		}
	}
	for(i=0;i<=k;i++) {
		c[i]+=carry;
		tmp=c[i];
		c[i]=tmp%10;
		carry=tmp/10;
	}
	
	for(i=k;c[i]==0;i--);
    int d=i;
	for(;i>=0;i--){
        out[d-i]=c[i]+'0';
        printf("%d",c[i]);
    }
	printf("\n");
}
int main(){
    int n;
    while (scanf("%d",&n)) {
        if (n==0) {
            printf("1\n");
        }
        char out[55][200];
        char str1[200]={'1'};
        char str2[20];
        char ad[200];
        char aad[200]={'0'};
        for (int i=1;i<n+1;i++ ) {
            sprintf(str2,"%d",i);
            mul(str1, str2, out[i]);
            strcpy(str1, out[i]);
            add(aad, str1,ad);
            strcpy(aad, ad);
        }
        printf("%s\n",ad);
    }
}
```
```c
#include <stdio.h>
int panduansushu(int i){////
    int aa=0;
    for (int p=2;p*p<=i;p++) {
            if(i%p==0){
                aa--;
                break;
            }
        }
    if (aa==0) {
        return 1;
    }
    else {
        return 0;
    }
}
int main(){
	int t;
    scanf("%d",&t);
    for (int  o=0; o<t;o++) {
        int j,k=1;
        scanf("%d",&j);
        if (panduansushu(j)) {
            printf("1\n");
            continue;
        }
        int i;
        for (i=2; i*i<=j;i++) {
            if (j%i==0) {
                k+=i+j/i;
                continue;
            }
        }
        i-=1;
        if(i*i==j) k-=i;
        printf("%d\n",k);
    }
    return 0;
}
```
```c
#include <stdio.h>
int main(){
    long long M1,M2;
    while (scanf("%lld %lld",&M1,&M2)!=EOF) {
        long long R1=0,R2=0,R3=0;
        char c;
        getchar();
        c=getchar();
        while (c<'G'&&c>='A') {
            if (c=='A') {
                R1=M1;
            }
            else if (c=='B') {
                R2=M2;
            }
            else if (c=='C') {
                M1=R3;
            }
            else if (c=='D') {
                M2=R3;
            }
            else if (c=='E') {
                R3=R1+R2;
            }
            else {
                R3=R1-R2;
            }
            c=getchar();
        }
        printf("%lld,%lld\n",M1,M2);
    }
    return 0;
}
```
### 大数相关应用
```c
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

int a[1000],b[1000],c[1000];
 
//返回两者较大值 
int max(int a,int b){
	if(a>b)return a;
	else return b;
}

//将数组设置为0 
int setZero(int*num,int len){
	for(int i=0;i<len;i++)
		num[i]=0;
}

//比较两个数组形式数字大小 
int compare(int*num1,int*num2){
	int i,j;
	for(i=999;num1[i]==0;i--);
	for(j=999;num2[j]==0;j--);
	if(i<j)return -1;
	else if(i>j)return 1;
	else{
		for(;i>=0;i--){
			if(num1[i]>num2[i])
				return 1;
			else if(num1[i]<num2[i])
				return -1;
		}
		return 0;
	}
}

//将一个数组赋给另一个数组 
int copy(int*num1,int*num2){
	int i,j;
	for(i=0;i<1000;i++)
		num1[i]=0;
	for(i=999;num2[i]==0;i--);
	for(j=0;j<=i;j++)
		num1[j]=num2[j];
	return i+1;
}

//大数加法 
void add(char*str1,char*str2){
	setZero(a,1000);
	setZero(b,1000);
	setZero(c,1000);
	printf("%s + %s = ",str1,str2);
		
	int i,carry=0;
	int len1=strlen(str1),len2=strlen(str2),len=max(len1,len2);
	for(i=0;i<len1;i++)
		a[i]=str1[len1-1-i]-'0';
	for(i=0;i<len2;i++)
		b[i]=str2[len2-1-i]-'0';
	for(i=0;i<len;i++){
		c[i]=(a[i]+b[i]+carry)%10;
		carry=(a[i]+b[i]+carry)/10;
	}
	

	if(carry!=0)
		c[len++]=1;
	for(i=len-1;i>=0;i--)
		printf("%d",c[i]);
	printf("\n");
}

//大数减法 
void sub(char*str1,char*str2){
	setZero(a,1000);
	setZero(b,1000);
	setZero(c,1000);
	printf("%s - %s = ",str1,str2);
	
	int i,borrow=0;
	int len1=strlen(str1),len2=strlen(str2),len=max(len1,len2);
	for(i=0;i<len1;i++)
		a[i]=str1[len1-1-i]-'0';
	for(i=0;i<len2;i++)
		b[i]=str2[len2-1-i]-'0';	
	
	//初步根据位数判断两数大小	
	if(len2>len1){ 
		printf("-");
		for(i=0;i<len;i++){
			c[i]=b[i]-a[i]-borrow;
			if(c[i]<0){
				borrow=1;
				c[i]+=10;
			}
			else
				borrow=0;
		}
	}
	else{
		for(i=0;i<len;i++){
			c[i]=a[i]-b[i]-borrow;
			if(c[i]<0&&i+1<len){
				borrow=1;
				c[i]+=10;
			}
			else
				borrow=0;
		}
	}
	//如果发现被减数小于减数，则重新计算，用减数减去被减数，输出负号 
	if(c[len-1]<0){
		printf("-");
		for(i=0;i<len;i++){
			c[i]=b[i]-a[i]-borrow;
			if(c[i]<0&&i+1<len){
				borrow=1;
				c[i]+=10;
			}
			else
				borrow=0;
		}
	}
	
	
	while(c[len-1]==0&&len>1)
		len--;
	for(i=len-1;i>=0;i--)
		printf("%d",c[i]);
	printf("\n");
}

//大数乘法 
void mul(char*str1,char*str2) {
	setZero(a,1000);
	setZero(b,1000);
	setZero(c,1000);
	printf("%s * %s = ",str1,str2);
	
	int i,j,k,carry=0,tmp; 
	int len1=strlen(str1),len2=strlen(str2);
	for(i=0;i<len1;i++)
		a[i]=str1[len1-1-i]-'0';
	for(i=0;i<len2;i++)
		b[i]=str2[len2-1-i]-'0';
	
	for(i=0;i<len1;i++){
		for(k=i,j=0;j<len2;j++,k++){
			c[k]+=a[i]*b[j];
		}
	}
	for(i=0;i<=k;i++) {
		c[i]+=carry;
		tmp=c[i];
		c[i]=tmp%10;
		carry=tmp/10;
	}
	
	for(i=k;c[i]==0;i--);
	for(;i>=0;i--)
		printf("%d",c[i]);
	printf("\n");
}


//大数除法 
void div(char*str1,char*str2){
	setZero(a,1000);
	setZero(b,1000);
	setZero(c,1000);
	printf("%s / %s = ",str1,str2);
	
	int i,j,tmp,tmp2=0,borrow=0,temp[1000]={0},temp2[1000]={0};
	int len1=strlen(str1),len2=strlen(str2);
	for(i=0;i<len1;i++)
		a[i]=str1[len1-1-i]-'0';
	for(i=0;i<len2;i++)
		b[i]=str2[len2-1-i]-'0';
	
	if(compare(a,b)<0){
		printf("0\n");
		return;
	}
	
	while(compare(a,b)>=0){			
		tmp=len1-len2;
		if(tmp==tmp2&&tmp>0)
			tmp--;
		tmp2=tmp;
		
		setZero(temp2,1000);
		for(i=len1-1;i>=tmp;i--)
			temp2[i]=b[i-tmp];
		copy(temp,a);
		
		if(compare(temp,temp2)<0)
				continue;
		for(j=1;;j++){
			borrow=0;
			for(i=tmp;i<len1;i++){
				temp[i]=a[i]-temp2[i]-borrow;
				if(temp[i]<0){
					borrow=1;
					temp[i]+=10;
				}
				else
					borrow=0;
			}
			
			len1=copy(a,temp);			
			c[tmp]=j;
			if(compare(temp,temp2)<0)
				break;
		}
	}
	
	for(i=999;c[i]==0;i--);
	for(;i>=0;i--)
		printf("%d",c[i]);
	printf("\n");
}

int main() {
	add("265151916516519419516","15616651622161651616");
	sub("163165165161984116165","15454874487989819449");
	mul("798794149194949451949","98491516194941631316");
	div("16516498416516516191981916516165","12345678");
}
```
# 归并排序（快速排序）
```c

#include<stdio.h>
#define ArrLen 20
void printList(int arr[], int len) {
	int i;
	for (i = 0; i < len; i++) {
		printf("%d\t", arr[i]);
	}
}
void merge(int arr[], int start, int mid, int end) {
	int result[ArrLen];
	int k = 0;
	int i = start;
	int j = mid + 1;
	while (i <= mid && j <= end) {
		if (arr[i] < arr[j]){
			result[k++] = arr[i++];
        }
		else{
			result[k++] = arr[j++];
        }
	}
	if (i == mid + 1) {
		while(j <= end)
			result[k++] = arr[j++];
	}
	if (j == end + 1) {
		while (i <= mid)
			result[k++] = arr[i++];
	}
	for (j = 0, i = start ; j < k; i++, j++) {
		arr[i] = result[j];
	}
}
 
void mergeSort(int arr[], int start, int end) {
	if (start >= end)
		return;
	int mid = ( start + end ) / 2;
	mergeSort(arr, start, mid);
	mergeSort(arr, mid + 1, end);
	merge(arr, start, mid, end);
}
 
int main()
{
	int arr[] = {4, 7, 6, 5, 2, 1, 8, 2, 9, 1};
	mergeSort(arr, 0, 9);
	printList(arr, 10);
	system("pause");
	return 0;

————————————————
版权声明：本文为CSDN博主「Don't_Touch_Me」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/assiduous_me/article/details/89414914
```
# 十进制转其他进制
```c
#include "stdio.h"
#include "stdlib.h"
#define N	10
static void base_convert(void)
{
    int num,base;
    int n[128];
    int i = 0;
    
	printf("please enter the coverted num:");
    scanf("%d",&num);//输入任意的十进制
    printf("please enter the base:");
    scanf("%d",&base);//输入想要转的进制
    
    do
    {
        n[i] = num % base;//取余
   		num = num / base;
    	i++;
    }while(num != 0);
    
    for(i --;i >= 0;i--)
	{
		if(n[i]>=10)
			printf("%c",n[i]-10+'A');
		else
        printf("%d",n[i]);
	}
    printf("\n");
}

int main()
{
	base_convert();
	exit(0);
}
————————————————
版权声明：本文为CSDN博主「不断提高」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_45075787/article/details/114287220
```
```c
（一）任意进制转十进制

#include <stdio.h>
int main(){
	int x,p;   //x输入数字  p该数的进制数  
	scanf("%d",&x);
	scanf("%d",&p);
	int y=0,product=1;
	while(x!=0){
		y=y+(x%10)*product;
		x=x/10;
		product=product*p;
	}
	printf("%d",y);
	return 0;
} 
（二）十进制转任意进制
注意：这里只能用do...while（原因：如果输入的是0，那么我们希望a[0]=0）

#include <stdio.h>
int main(){
	int x,p; //x为十进制数，p为目标进制大小 
	scanf("%d",&x);
	scanf("%d",&p);
	int a[100]; //存放余数 
	int count=0;
	do{
		a[count++]=x%p;
		x=x/p;
	}while(x!=0);//当商不为0时进行循环 
	
	for(int i=count-1;i>=0;i--){
		printf("%d",a[i]);
	}
} 
（三）二进制转十六进制
主要思路：确定十六进制数组大小->确定二进制数数组大小->二进制每过4位存入十六进制1位

思路：输入的二进制数可能能不是4的整数倍，那么我们该如何处理呢？我们知道二进制不够4位，用0占位。于是我先将输入的二进制数除以10000取余(看4位)，这样就确定十六进制数组的大小，反过*4来就知道了二进制数的大小。
 

#include <stdio.h>
#include <math.h>
int main(){
	//输入2进制数 
	int x;
	scanf("%d",&x); 
	
	//确定：16进制数组大小size与2进制数组大小size*4.
	int X=x;
	int size=0; 
	while(true){
		if(X%10000!=0){ //采取看4位二进制的方法 
			size++;
			X=X/10000;
		}else{
			break;
		} 
	}
	char tt[size];   //16进制数数组 
	int t[size*4]; //2进制数数组 
      //存入 
	int sum=0;
	int count=0;
	for(int i=0;i<sizeof(t)/sizeof(int);i++){
		t[i]=x%10;
		x=x/10;
		sum=sum+t[i]*pow(2,count);
		count++;
		if(count%4==0){
			if(sum>=10){
				tt[--size]=65+(sum-10);  //字符'A'的ascii码为65 
			}else{
				tt[--size]='0'+sum;    
			}
			count=0;
			sum=0;
		}	
	}
	for(int i=0;i<sizeof(tt);i++){
		printf("%c",tt[i]);
	}
	return 0;
} 

————————————————
版权声明：本文为CSDN博主「Zero-place」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_41877184/article/details/88753144
```
```c

```
```c
qsort函数原型
void qsort(
    void *base,
    size_t nmemb,
    size_t size,
    int (*compar)(const void *, const void *)
    );
头文件:<stdlib.h> 函数功能：qsort()函数的功能是对数组进行排序，数组有nmemb个元素，每个元素大小为size。

参数base - base指向数组的起始地址，通常该位置传入的是一个数组名 参数nmemb - nmemb表示该数组的元素个数 参数size - size表示该数组中每个元素的大小（字节数） 参数(*compar)(const void *, const void *) - 此为指向比较函数的函数指针，决定了排序的顺序。 函数返回值：无 注意：如果两个元素的值是相同的，那么它们的前后顺序是不确定的。也就是说qsort()是一个不稳定的排序算法。

compar参数
compar参数是qsort函数排序的核心内容，它指向一个比较两个元素的函数，注意两个形参必须是const void *型，同时在调用compar 函数（compar实质为函数指针，这里称它所指向的函数也为compar）时，传入的实参也必须转换成const void *型。在compar函数内部会将const void *型转换成实际类型，见下文。

int compar(const void *p1, const void *p2);
如果compar返回值小于0（< 0），那么p1所指向元素会被排在p2所指向元素的前面 如果compar返回值等于0（= 0），那么p1所指向元素与p2所指向元素的顺序不确定 如果compar返回值大于0（> 0），那么p1所指向元素会被排在p2所指向元素的后面 因此，如果想让qsort()进行从小到大（升序）排序，那么一个通用的compar函数可以写成这样：

 int compare (const void * a, const void * b)
 {
   if ( *(MyType*)a <  *(MyType*)b ) return -1;
   if ( *(MyType*)a == *(MyType*)b ) return 0;
   if ( *(MyType*)a >  *(MyType*)b ) return 1;
 }
注意：你要将MyType换成实际数组元素的类型。 或者

//升序排序
 int compare (const void * a, const void * b)
 {
     return ( *(int*)a - *(int*)b );
 }
//降序排列
 int compare (const void * a, const void * b)
 {
     return ( *(int*)b - *(int*)a );
 }
int 数组排序
/* qsort example */
#include <stdio.h>     
#include <stdlib.h>     

int values[] = { 40, 10, 100, 90, 20, 25 };

int compare (const void * a, const void * b)
{
  return ( *(int*)a - *(int*)b );
}

int main ()
{
  int n;
  qsort (values, sizeof(values)/sizeof(values[0]), sizeof(int), compare);
  for (n=0; n<sizeof(values)/sizeof(values[0]); n++)
     printf ("%d ",values[n]);
  return 0;
}
结构体排序
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include<stdlib.h>
// void qsort(void* base, size_t num, size_t size, int(*compare)(const void*, const void*))

typedef struct
{
    char name[30];   // 学生姓名
    int Chinese;    // 语文成绩
    int Math;        // 数学成绩  
    int English;     // 英语成绩
}st; 
int cmp(const void* a, const void* b)
{
    st* pa = (st*)a;
    st* pb = (st*)b;
    int num1 = pa->Chinese + pa->English + pa->Math;
    int num2 = pb->Chinese + pb->English + pb->Math;

    //return (int)num1 - num2;   // 从小到大，
    return (int)num2 - num1;   //  从大到小
}
int main(void)
{
    st students[7] = {
        {"周",97,68,45},
        {"吴",100,32,88},
        {"郑",78,88,78},
        {"王",87,90,89},
        {"赵",87,77,66},
        {"钱",59,68,98},
        {"孙",62,73,89}
    };
    qsort(students, 7, sizeof(st), cmp);   // 注意区别 students 与 st

    for (int i = 0; i < 7; i++)
    {
        printf("%s%4d%4d%4d\t", students[i].name, students[i].Chinese, students[i].Math, students[i].English);
        printf("总分：%d\n", students[i].Chinese + students[i].English + students[i].Math);
    }

    system("pause");
    return 0;
}
字符串指针数组排序
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int compare(const void *arg1, const void *arg2);

int
main(int argc, char** argv)
{
    int i;

    char *arr[5] = { "i", "love", "c", "programming", "language" };

    qsort(arr, sizeof(arr)/sizeof(arr[0]), sizeof(char *), compare);

    for (i = 0; i < 5; i++) {
        printf("%s ", arr[i]);
    }
    printf("\n");

}

int compare(const void *arg1, const void *arg2) {
    char *a = *(char**)arg1;
    char *b = *(char**)arg2;
    int result = strcmp(a, b);
    if (result > 0) {
        return 1;
    }
    else if (result < 0) {
        return -1;
    }
    else {
        return 0;
    }
}
那么我们向qsort传入arr之后，qsort将arr理解为指向数组中第一个元素的指针，所以形参表中，arg1和arg2其实是指向“指向常量字符串的指针”的指针，是char**。而我们需要传给strcmp这个字符串比较函数的，是“指向字符串的指针”，是char*，所以我们将void*转换为char**，然后解引用，得到char*，赋予a和b。接下来使用strcmp对a和b进行比较。(数组名本身算一层指针，而里面的内容又是一层指针，数组存放的是指向字符串的地址)

字符串二维数组排序
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int compare(const void *arg1, const void *arg2);

int
main(int argc, char** argv)
{
    int i;

    char arr[5][16] = { "i", "love", "c", "programming", "language" };

    qsort(arr, sizeof(arr)/sizeof(arr[0]), sizeof(arr[0]), compare);
    printf("%s\n", arr[0]);
    for (i = 0; i < 5; i++) {
        printf("%s ", arr[i]);
    }
    printf("\n");
}

int compare(const void *arg1, const void *arg2) {
    char *a = (char*)arg1;
    char *b = (char*)arg2;
    int result = strcmp(a, b);
    if (result > 0) {
        return 1;
    }
    else if (result < 0) {
        return -1;
    }
    else {
        return 0;
    }
}
这里对二维数组进行排序，其实是对二维数组的第二维中存放的字符串进行排序。所以qsort(arr, sizeof(arr)/sizeof(arr[0]), sizeof(arr[0]), compare);对qsort函数的调用中，第二个参数是待排元素的个数（5个），第三个参数是待排元素的大小（16）。

我们将arr传入qsort函数，qsort函数将arr理解为指向数组第一个元素的指针，arr的第一个元素是arr[0][0]，所以参数arg1和arg2指的是指向"a[i][0]"的指针，我们知道，a[i][0]是字符，就是char，所以arg1和arg2指的是char *。我们将void*转换为char*，赋予a和b，调用strcmp函数对a和b进行比较。

整型二维数组(力扣题目)
最接近原点的 K 个点
我们有一个由平面上的点组成的列表 points。需要从中找出 K 个距离原点 (0, 0) 最近的点。（这里，平面上两点之间的距离是欧几里德距离。）你可以按任何顺序返回答案。除了点坐标的顺序之外，答案确保是唯一的。

示例 1：

输入：points = [[1,3],[-2,2]], K = 1 输出：[[-2,2]] 解释： (1, 3) 和原点之间的距离为sqrt(10)， (-2, 2) 和原点之间的距离为 sqrt(8)， 由于 sqrt(8) < sqrt(10)，(-2, 2) 离原点更近。 我们只需要距离原点最近的 K = 1 个点，所以答案就是 [[-2,2]]。 示例 2： 输入：points = [[3,3],[5,-1],[-2,4]], K = 2 输出：[[3,3],[-2,4]] （答案 [[-2,4],[3,3]] 也会被接受。）
提示： 1 <= K <= points.length <= 10000 -10000 < points[i][0] < 10000 -10000 < points[i][1] < 10000

/* qsort排序二维数组，cmp的每个元素都是一个独立的 int 数组，也就是指针 */
int cmp(const void* a, const void* b) {

    // 转换为对应一维数组
    int* arry1 = *(int**)a;
    int* arry2 = *(int**)b;

    // 获取对应arry1 的两个元素
    int x1 = *arry1;
    int y1 = *(arry1 + 1);

    int x2 = *arry2;
    int y2 = *(arry2+1);

    return (x1*x1 + y1*y1) - (x2*x2 + y2*y2);
}


int** kClosest(int** points, int pointsSize, int* pointsColSize, int K, int* returnSize, int** returnColumnSizes){
    if(points==NULL || pointsSize==0 || K==0) return NULL;

    qsort(points, pointsSize, sizeof(int)*pointsColSize[0], cmp);
    /*   这里注意 qsort 的传参，使用不当会报错
    Line 11: Char 11: runtime error: load of misaligned address 0x602000000032 for type 'int *', which requires 8 byte alignment (solution.c)       0x602000000032: note: pointer points here
    */

    // 指定return输出的二维数组是包含有几个一维数组
    *returnSize = pointsSize > K ? K : pointsSize;

    *returnColumnSizes = (int*)malloc(sizeof(int*)*(*returnSize));
    // 指定每个一维数组的 col 
    for(int i = 0; i< (*returnSize); i++) {
        (*returnColumnSizes)[i] = 2;
    }
    return points;
}
```  


